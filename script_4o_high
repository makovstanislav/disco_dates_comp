/**
 * Office Script: synchronize dates from GFE to Main and flag changes.
 *
 * • Starts at row 3 (0-based index 2).
 * • Copies First Available / Discontinue dates into Main cols E/F.
 * • Marks "Y" in Main cols G/H when dates differ.
 * • All variables explicitly typed.
 */

// Convert Excel serial date to JS milliseconds (handles 1900 leap year bug)
function excelSerialToMillis(serial: number): number {
  const offsetDays: number = serial > 60 ? serial - 1 : serial;
  const epoch: Date = new Date(Date.UTC(1899, 11, 31));
  const millis: number = epoch.getTime() + offsetDays * 24 * 60 * 60 * 1000;
  return millis;
}

// Convert any cell value to milliseconds (or undefined)
function toMillis(value: ExcelScript.CellValue): number | undefined {
  const v: ExcelScript.CellValue = value;
  if (v === "" || v === null || v === undefined) {
    return undefined;
  }
  if (typeof v === "number") {
    return excelSerialToMillis(v);
  }
  if (v instanceof Date) {
    return v.getTime();
  }
  if (typeof v === "string") {
    const dt: Date = new Date(v as string);
    const time: number = dt.getTime();
    return isNaN(time) ? undefined : time;
  }
  return undefined;
}

// Compare two cell values as dates or blanks
function datesEqual(a: ExcelScript.CellValue, b: ExcelScript.CellValue): boolean {
  const msA: number | undefined = toMillis(a);
  const msB: number | undefined = toMillis(b);
  if (msA === undefined && msB === undefined) {
    return true;
  }
  return msA !== undefined && msB !== undefined && msA === msB;
}

// Main function
function main(workbook: ExcelScript.Workbook): void {
  const START_ROW: number = 2;
  const wsMain: ExcelScript.Worksheet = workbook.getWorksheet("Main")!;
  const wsGFE: ExcelScript.Worksheet  = workbook.getWorksheet("GFE")!;

  // Read GFE data
  const gfeRange: ExcelScript.Range = wsGFE.getUsedRange()!;
  const gfeData: ExcelScript.CellValue[][] = gfeRange.getValues() as ExcelScript.CellValue[][];

  // Build lookup map
  interface DatesPair { fa: ExcelScript.CellValue; disco: ExcelScript.CellValue; }
  const lookup: Record<string, DatesPair> = {};
  for (let i: number = START_ROW; i < gfeData.length; i++) {
    const mat: ExcelScript.CellValue = gfeData[i][0];
    const sea: ExcelScript.CellValue = gfeData[i][1];
    if (!mat || !sea) {
      continue;
    }
    const key: string = String(mat) + "|" + String(sea);
    lookup[key] = {
      fa: gfeData[i][2],
      disco: gfeData[i][3]
    };
  }

  // Read Main data
  const mainRange: ExcelScript.Range = wsMain.getUsedRange()!;
  const mainData: ExcelScript.CellValue[][] = mainRange.getValues() as ExcelScript.CellValue[][];

  // Update Main rows
  for (let j: number = START_ROW; j < mainData.length; j++) {
    const matVal: ExcelScript.CellValue = mainData[j][0];
    const seaVal: ExcelScript.CellValue = mainData[j][1];
    if (!matVal || !seaVal) {
      continue;
    }
    const lookupKey: string = String(matVal) + "|" + String(seaVal);
    const dp: DatesPair | undefined = lookup[lookupKey];
    if (!dp) {
      continue;
    }

    // Copy dates to cols E/F
    mainData[j][4] = dp.fa;
    mainData[j][5] = dp.disco;

    // Flag changes in G/H
    if (!datesEqual(mainData[j][2], dp.fa)) {
      mainData[j][6] = "Y";
    }
    if (!datesEqual(mainData[j][3], dp.disco)) {
      mainData[j][7] = "Y";
    }
  }

  // Write back to Main
  mainRange.setValues(mainData);
}
