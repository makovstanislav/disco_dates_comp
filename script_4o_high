/**
 * Office Script: synchronize dates from GFE to Main and flag changes.
 * • Starts at row 3 (0-based index 2).
 * • Copies First Available / Discontinue dates into Main cols E/F.
 * • Marks "Y" in Main cols G/H when dates differ.
 * • All variables explicitly typed.
 */

// Convert Excel serial date to JS milliseconds (handles 1900 leap year bug)
function excelSerialToMillis(serial: number): number {
  const offsetDays: number = serial > 60 ? serial - 1 : serial;
  const baseDate: Date = new Date(Date.UTC(1899, 11, 31));
  const resultMillis: number = baseDate.getTime() + offsetDays * 86400000;
  return resultMillis;
}

// Convert any cell value to milliseconds (undefined if blank/non-date)
function toMillis(value: ExcelScript.CellValue): number | undefined {
  if (value === null || value === undefined || value === "") {
    const emptyUndefined: undefined = undefined;
    return emptyUndefined;
  }
  if (typeof value === "number") {
    const serialNum: number = value;
    const msFromSerial: number = excelSerialToMillis(serialNum);
    return msFromSerial;
  }
  if (value instanceof Date) {
    const dateObj: Date = value;
    const msFromDate: number = dateObj.getTime();
    return msFromDate;
  }
  if (typeof value === "string") {
    const strVal: string = value;
    const parsedDate: Date = new Date(strVal);
    const parsedMillis: number = parsedDate.getTime();
    if (isNaN(parsedMillis)) {
      const undef2: undefined = undefined;
      return undef2;
    }
    return parsedMillis;
  }
  const undef3: undefined = undefined;
  return undef3;
}

// Compare two cell values as dates or blanks
function datesEqual(a: ExcelScript.CellValue, b: ExcelScript.CellValue): boolean {
  const msA: number | undefined = toMillis(a);
  const msB: number | undefined = toMillis(b);
  if (msA === undefined && msB === undefined) {
    const equalBlanks: boolean = true;
    return equalBlanks;
  }
  if (msA !== undefined && msB !== undefined) {
    const equalDates: boolean = msA === msB;
    return equalDates;
  }
  const notEqual: boolean = false;
  return notEqual;
}

// Main function
function main(workbook: ExcelScript.Workbook): void {
  const START_ROW: number = 2;

  const mainWorksheet: ExcelScript.Worksheet = workbook.getWorksheet("Main")!;
  const gfeWorksheet: ExcelScript.Worksheet = workbook.getWorksheet("GFE")!;

  // Read GFE data
  const gfeRange: ExcelScript.Range = gfeWorksheet.getUsedRange()!;
  const gfeValues: ExcelScript.CellValue[][] = gfeRange.getValues() as ExcelScript.CellValue[][];

  // Build lookup of material|season → dates
  interface DatesPair { faDate: ExcelScript.CellValue; discoDate: ExcelScript.CellValue; }
  const dateLookup: Record<string, DatesPair> = {};
  for (let rowIndex: number = START_ROW; rowIndex < gfeValues.length; rowIndex = rowIndex + 1) {
    const materialCell: ExcelScript.CellValue = gfeValues[rowIndex][0];
    const seasonCell: ExcelScript.CellValue = gfeValues[rowIndex][1];
    const materialKey: string = String(materialCell);
    const seasonKey: string = String(seasonCell);
    if (materialKey === "" || seasonKey === "") {
      continue;
    }
    const lookupKey: string = materialKey + "|" + seasonKey;
    const faDateVal: ExcelScript.CellValue = gfeValues[rowIndex][2];
    const discoDateVal: ExcelScript.CellValue = gfeValues[rowIndex][3];
    dateLookup[lookupKey] = { faDate: faDateVal, discoDate: discoDateVal };
  }

  // Read Main data
  const mainRange: ExcelScript.Range = mainWorksheet.getUsedRange()!;
  const mainValues: ExcelScript.CellValue[][] = mainRange.getValues() as ExcelScript.CellValue[][];

  // Update Main rows
  for (let rowIndex: number = START_ROW; rowIndex < mainValues.length; rowIndex = rowIndex + 1) {
    const materialCell: ExcelScript.CellValue = mainValues[rowIndex][0];
    const seasonCell: ExcelScript.CellValue = mainValues[rowIndex][1];
    const materialKey: string = String(materialCell);
    const seasonKey: string = String(seasonCell);
    if (materialKey === "" || seasonKey === "") {
      continue;
    }
    const lookupKey: string = materialKey + "|" + seasonKey;
    const datesPair: DatesPair | undefined = dateLookup[lookupKey];
    if (datesPair === undefined) {
      continue;
    }

    const existingFa: ExcelScript.CellValue = mainValues[rowIndex][2];
    const existingDisco: ExcelScript.CellValue = mainValues[rowIndex][3];
    const newFa: ExcelScript.CellValue = datesPair.faDate;
    const newDisco: ExcelScript.CellValue = datesPair.discoDate;

    // Copy new dates
    mainValues[rowIndex][4] = newFa;
    mainValues[rowIndex][5] = newDisco;

    // Flag First Available change
    const faChanged: boolean = !datesEqual(existingFa, newFa);
    if (faChanged) {
      mainValues[rowIndex][6] = "Y";
    }

    // Flag Discontinue change
    const discoChanged: boolean = !datesEqual(existingDisco, newDisco);
    if (discoChanged) {
      mainValues[rowIndex][7] = "Y";
    }
  }

  // Write back updated data
  mainRange.setValues(mainValues);
}
