/**
 * Office Script: synchronize dates from “GFE” → “Main” and flag changes.
 *
 * • Starts at row 3 (0-based index 2).
 * • Copies First Available / Discontinue dates into Main cols E/F.
 * • Marks “Y” in Main cols G/H when dates differ.
 * • Converts Excel serial numbers to JS timestamps for accurate comparison.
 */

// Convert Excel date serial number to JS milliseconds (handles 1900 leap year bug)
function excelSerialToMillis(serial: number): number {
  // Excel considers 1900 as leap year, so dates >= Mar 1, 1900 (serial >= 61) are offset by 1
  const serialDays: number = serial > 60 ? serial - 1 : serial;
  const epoch: Date = new Date(Date.UTC(1899, 11, 31));
  const millis: number = epoch.getTime() + serialDays * 24 * 60 * 60 * 1000;
  return millis;
}

// Get milliseconds for a cell value (Date or number); undefined otherwise
function toMillis(value: ExcelScript.CellValue): number | undefined {
  if (value === "" || value === null || value === undefined) {
    return undefined;
  }
  if (value instanceof Date) {
    return value.getTime();
  }
  if (typeof value === "number") {
    return excelSerialToMillis(value);
  }
  // Attempt to parse string date
  if (typeof value === "string") {
    const dt: Date = new Date(value);
    return isNaN(dt.getTime()) ? undefined : dt.getTime();
  }
  return undefined;
}

// Check equality: both blank → equal; else both defined and millis equal
function datesEqualValue(a: ExcelScript.CellValue, b: ExcelScript.CellValue): boolean {
  const ma: number | undefined = toMillis(a);
  const mb: number | undefined = toMillis(b);
  if (ma === undefined && mb === undefined) {
    return true;
  }
  return ma !== undefined && mb !== undefined && ma === mb;
}

function main(workbook: ExcelScript.Workbook): void {
  const START_ROW: number = 2;

  const wsMain: ExcelScript.Worksheet = workbook.getWorksheet("Main")!;
  const wsGFE: ExcelScript.Worksheet  = workbook.getWorksheet("GFE")!;

  const gfeRange: ExcelScript.Range = wsGFE.getUsedRange()!;
  const gfeData: ExcelScript.CellValue[][] = gfeRange.getValues() as ExcelScript.CellValue[][];

  interface DatesPair { fa: ExcelScript.CellValue; disco: ExcelScript.CellValue; }
  const lookup: Record<string, DatesPair> = {};

  for (let i: number = START_ROW; i < gfeData.length; i++) {
    const mat: string = String(gfeData[i][0]);
    const sea: string = String(gfeData[i][1]);
    if (!mat || !sea) continue;
    lookup[`${mat}|${sea}`] = { fa: gfeData[i][2], disco: gfeData[i][3] };
  }

  const mainRange: ExcelScript.Range = wsMain.getUsedRange()!;
  const mainData: ExcelScript.CellValue[][] = mainRange.getValues() as ExcelScript.CellValue[][];

  for (let i: number = START_ROW; i < mainData.length; i++) {
    const mat: string = String(mainData[i][0]);
    const sea: string = String(mainData[i][1]);
    if (!mat || !sea) continue;
    const key: string = `${mat}|${sea}`;
    const dp: DatesPair | undefined = lookup[key];
    if (!dp) continue;

    // Copy dates
    mainData[i][4] = dp.fa;
    mainData[i][5] = dp.disco;

    // Flag changes
    if (!datesEqualValue(mainData[i][2], dp.fa)) {
      mainData[i][6] = "Y";
    }
    if (!datesEqualValue(mainData[i][3], dp.disco)) {
      mainData[i][7] = "Y";
    }
  }

  mainRange.setValues(mainData);
}
